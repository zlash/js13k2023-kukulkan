import { min } from "~aliasedFunctions";
import { loadSamples, renderSamples } from "~audio";
import { DEBUG } from "~autogenerated";
import { gameInit, gameMainLoop, entities } from "~game";
import { initDebugGame } from "~gameSession";
import { inputUpdate } from "~input";
import { loadScreenInit, loadScreenLoop } from "~loadingScreen";
import { renderGameFrame, debugDiv, bakeTextures, setRenderFloorOn } from "~renderer";
import { roadmapInit, roadmapLoop } from "~roadmap";
import { bakeSdfs } from "~sdfSprites";
import { titlescreenInit, titlescreenLoop } from "~titlescreen";

let lastTimestamp = -1;
let ts = 0;

let bafAverage: number[];
let fAverage: number[];

export const ModeTitlescreen = 0;
export const ModeGame = 1;
export const ModeRoadmap = 2;
export const ModeLoading = 3;
let gameMode: number;

export let currentModeLoop: (dts: number) => void;

export const setMode = (mode: number) => {
    switch (mode) {
        case ModeTitlescreen:
            titlescreenInit();
            currentModeLoop = titlescreenLoop;
            break;
        case ModeRoadmap:
            roadmapInit();
            currentModeLoop = roadmapLoop;
            break;
        case ModeGame:
            gameInit();
            currentModeLoop = gameMainLoop;
            break;
        case ModeLoading:
            loadScreenInit();
            currentModeLoop = loadScreenLoop;
            break;
    }
    gameMode = mode;
}

const mainLoop = (timestamp: number) => {
    if (lastTimestamp < 0) {
        lastTimestamp = timestamp - 1000 / 60;
    }

    let debugTimestamp = 0;

    if (DEBUG) {
        debugTimestamp = performance.now();
    }

    inputUpdate();

    let dts = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;
    ts += dts;

    if (DEBUG) {
        if (!bafAverage) bafAverage = [];
        bafAverage.push(dts * 1000);
    }

    dts = min(1 / 15, dts);

    const maxFramerateStep = 1 / 60;

    while (dts > 0) {
        currentModeLoop(min(dts, maxFramerateStep));
        dts -= maxFramerateStep;
    }

    renderGameFrame(ts);

    if (DEBUG) {

        if (bafAverage.length >= 120) {
            bafAverage[0] = bafAverage[bafAverage.length - 1];
            bafAverage.pop();
        }
        const bafAvg = bafAverage.reduce((acc, cur) => acc + cur / bafAverage.length, 0);

        if (!fAverage) fAverage = [];
        fAverage.push(performance.now() - debugTimestamp);
        if (fAverage.length >= 120) {
            fAverage[0] = fAverage[fAverage.length - 1];
            fAverage.pop();
        }
        const fAvg = fAverage.reduce((acc, cur) => acc + cur / fAverage.length, 0);

        debugDiv.innerHTML = `Browser frame avg: ${bafAvg.toFixed(4)} ms ðŸŒŠðŸŒŠ Own frame avg: ${fAvg.toFixed(4)} ms ðŸ”¥ðŸ”¥ Actual running time: ${(ts).toFixed(4)}s || Entities ${entities ? entities.length : -1}`;
    }

    window.requestAnimationFrame(mainLoop);
};

export const initMain = () => {
    setMode(ModeLoading);

    window.requestAnimationFrame(mainLoop);
};