import { gl, initWebgl, createProgram, WebGLShaderBundle, getUniformLocation, Texture3d, createTexture3d, createUBO, texture3dSubdata, Framebuffer, createFramebuffer, setFramebuffer, resetFramebuffer, createTexture } from "./webgl";
import { gameDownscale, sdfSpritesAtlasSide, sdfTextureDepth, viewResolution } from "./constants";
import { screenVert, finalSdfFrag, sdfSpriteVert, sdfSpriteFrag, sdfFloorFrag, ortho2dVert, uvColorFrag, sdfScreenVert } from "./shaders/bundle";
import { DEBUG } from "./autogenerated";
import * as glEnum from "./webglEnums";
import { Mat4, Quaternion, Vec2, Vec3, Vec4, mat4, mat4Diagonal, mat4LookAt, mat4Ortho, mat4Perspective, mat4ToConsole, identityQuaternion, vec3, zAxis, zeroVector, vecClone, vecFMKA, vec4, vec4Splay, mat4Vec4Mul, vecMulK, vecNormalize, oneVector } from "./juvec";
import { Deg, floor, saturate } from "./aliasedFunctions";
import { fbmTexture, fillBufferWithRandomRange } from "~noise";
import { gameArea } from "~game";
import { floorPos } from "~player";
import { timeOfDay } from "~gameSession";

/*
Some stats from https://web3dsurvey.com/webgl2

GL_MAX_TEXTURE_SIZE                             1024 - 100%
MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS        50048 - 99.99%

*/
const createViewCanvas = () => {

    const canvas = document.createElement("canvas");
    canvas.width = viewResolution[0];
    canvas.height = viewResolution[1];

    return canvas;
};

export let debugDiv: HTMLDivElement;

let glCanvas: HTMLCanvasElement;

let sdfSpriteProgram: WebGLShaderBundle;
let sdfFloorProgram: WebGLShaderBundle;
let ortho2dProgram: WebGLShaderBundle;
let screenColorUvProgram: WebGLShaderBundle;

let unitQuadBuffer: WebGLBuffer;
let unitQuadVao: WebGLVertexArrayObject;

let ortho2dBuffer: WebGLBuffer;
let ortho2dVao: WebGLVertexArrayObject;

export let viewMatrix: Mat4;
let projMatrix: Mat4;

export let sdfTexture3d: Texture3d;
export let sdfTextureMaterial3d: Texture3d;

const terrainTextureSize = 1024;
let terrainNoiseTexture: Texture3d;
const whiteNoiseTextureSize = 1024;
let whiteNoiseTexture: Texture3d;

const ortho2dMaxSprites = 2000;
const ortho2dVertexAttributesSizeFloats = 12;
const ortho2dArraySizeFloats = ortho2dVertexAttributesSizeFloats * 6 * ortho2dMaxSprites;
const ortho2dSpritesFloatArray = new Float32Array(ortho2dArraySizeFloats);
let ortho2dNumSprites = 0;

const maxSdfSprites = 200;
let numSdfSprites = 0;
let sdfSpritesBuffer = new Float32Array(maxSdfSprites * 12 + 4);
let sdfSpritesUBOBuffer: WebGLBuffer;

let gameFramebuffer: Framebuffer;

let whitePixelTexture: WebGLTexture;

let renderFloor = false;

export const setRenderFloorOn = () => {
    renderFloor = true;
};

export const drawSdfSprite = (id: number, pos: Vec3, scale: number, quat?: Quaternion, mat2?: number, mat2alpha?: number) => {
    if (numSdfSprites >= maxSdfSprites) return;
    let idx = 4 * (1 + numSdfSprites);
    const yId = floor(id / sdfSpritesAtlasSide);
    const xId = id - yId * sdfSpritesAtlasSide;

    // Coords for sprite atlas ubication
    sdfSpritesBuffer[idx] = xId;
    sdfSpritesBuffer[idx + 1] = yId;
    sdfSpritesBuffer[idx + 2] = mat2 ?? 0;
    sdfSpritesBuffer[idx + 3] = mat2alpha ?? 0;

    idx += 4 * maxSdfSprites;
    sdfSpritesBuffer[idx] = pos[0];
    sdfSpritesBuffer[idx + 1] = pos[1];
    sdfSpritesBuffer[idx + 2] = pos[2];
    sdfSpritesBuffer[idx + 3] = scale;

    idx += 4 * maxSdfSprites;
    quat = quat ?? identityQuaternion;
    sdfSpritesBuffer[idx] = quat[0];
    sdfSpritesBuffer[idx + 1] = quat[1];
    sdfSpritesBuffer[idx + 2] = quat[2];
    sdfSpritesBuffer[idx + 3] = quat[3];

    ++numSdfSprites;
};

export const drawOrtho2d = (center: Vec2, size: Vec2, uv00?: Vec2, uv11?: Vec2, uvZ?: number, rotation?: number, color?: Vec4) => {
    let idx = ortho2dNumSprites * ortho2dVertexAttributesSizeFloats * 6;
    uv00 = uv00 ?? (zeroVector as Vec2);
    uv11 = uv11 ?? (zeroVector as Vec2);
    uvZ = uvZ ?? 0;
    rotation = rotation ?? 0;
    color = color ?? (oneVector as Vec4);
    for (let i = 0; i < 6; ++i) {
        let sideX = i == 2 || i == 3 || i == 5;
        let sideY = i == 1 || i >= 4;
        ortho2dSpritesFloatArray[idx++] = size[0] * (sideX ? 1 : -1) / 2;
        ortho2dSpritesFloatArray[idx++] = size[1] * (sideY ? 1 : -1) / 2;
        ortho2dSpritesFloatArray[idx++] = (sideX ? uv11 : uv00)[0];
        ortho2dSpritesFloatArray[idx++] = (sideY ? uv11 : uv00)[1];
        ortho2dSpritesFloatArray[idx++] = uvZ;
        ortho2dSpritesFloatArray[idx++] = center[0];
        ortho2dSpritesFloatArray[idx++] = center[1];
        ortho2dSpritesFloatArray[idx++] = rotation;
        ortho2dSpritesFloatArray[idx++] = color[0];
        ortho2dSpritesFloatArray[idx++] = color[1];
        ortho2dSpritesFloatArray[idx++] = color[2];
        ortho2dSpritesFloatArray[idx++] = color[3];
    }

    ++ortho2dNumSprites;
};

const lightDirectionPerTimeOfDay = [vec3(1, 1, 1.5), vec3(1, 0, 1.1), vec3(1, 1, 3)];
const lightColorPerTimeOfDay = [[0.95, 0.95, 0.5], [1, 0.6, 0.2], [0.6, 0.4, 0.8]];
const lightAmbientPerTimeOfDay = [[0.3, 0.3, 0.4], [0.4, 0.1, 0.1], [0.15, 0, 0.3]];
const lightBouncePerTimeOfDay = [[0.6, 0.6, 0.8], [0.2, 0.2, 0.2], [0.1, 0.1, 0.3]];

export const renderGameFrame = (ts: number) => {
    gl.clearColor(0, 0, 0, 1);

    // Lightning
    const lightDirection = lightDirectionPerTimeOfDay[timeOfDay];
    vecNormalize(lightDirection, lightDirection);
    const lightDirectionF32 = new Float32Array([lightDirection[0], lightDirection[1], lightDirection[2]]);
    const lightColorF32 = new Float32Array(lightColorPerTimeOfDay[timeOfDay]);
    const lightAmbientF32 = new Float32Array(lightAmbientPerTimeOfDay[timeOfDay]);
    const lightBounceF32 = new Float32Array(lightBouncePerTimeOfDay[timeOfDay]);
    // Todo, stop creating Float32Array every frame

    // Floor
    //////////////////////

    gl.bindBuffer(glEnum.ARRAY_BUFFER, unitQuadBuffer);
    gl.bindVertexArray(unitQuadVao);


    setFramebuffer(gameFramebuffer);
    gl.clear(glEnum.COLOR_BUFFER_BIT | glEnum.DEPTH_BUFFER_BIT);
    gl.enable(glEnum.DEPTH_TEST);


    if (renderFloor) {
        gl.useProgram(sdfFloorProgram.program);
        gl.activeTexture(glEnum.TEXTURE0);
        gl.bindTexture(glEnum.TEXTURE_3D, terrainNoiseTexture.tex);
        gl.activeTexture(glEnum.TEXTURE1);
        gl.bindTexture(glEnum.TEXTURE_3D, whiteNoiseTexture.tex);
        // TODO: Maybe base the whole vector stuff on float buffers
        gl.uniformMatrix4fv(sdfFloorProgram.uniforms["_mv"], false, new Float32Array(viewMatrix));
        gl.uniformMatrix4fv(sdfFloorProgram.uniforms["_mp"], false, new Float32Array(projMatrix));
        gl.uniform4fv(sdfFloorProgram.uniforms["_d"], new Float32Array([ts, floorPos, gameArea[0], gameArea[1]]));


        gl.uniform3fv(sdfFloorProgram.uniforms["_ld"], lightDirectionF32);
        gl.uniform3fv(sdfFloorProgram.uniforms["_lc"], lightColorF32);
        gl.uniform3fv(sdfFloorProgram.uniforms["_la"], lightAmbientF32);
        gl.uniform3fv(sdfFloorProgram.uniforms["_lb"], lightBounceF32);

        gl.drawArrays(glEnum.TRIANGLE_STRIP, 0, 4);
        renderFloor = false;
    }

    // SDF Sprites
    //////////////////////

    gl.useProgram(sdfSpriteProgram.program);

    // TODO: Maybe base the whole vector stuff on float buffers
    gl.uniformMatrix4fv(sdfSpriteProgram.uniforms["_mv"], false, new Float32Array(viewMatrix));
    gl.uniformMatrix4fv(sdfSpriteProgram.uniforms["_mp"], false, new Float32Array(projMatrix));

    gl.uniform3fv(sdfSpriteProgram.uniforms["_ld"], lightDirectionF32);
    gl.uniform3fv(sdfSpriteProgram.uniforms["_lc"], lightColorF32);
    gl.uniform3fv(sdfSpriteProgram.uniforms["_la"], lightAmbientF32);
    gl.uniform3fv(sdfSpriteProgram.uniforms["_lb"], lightBounceF32);

    // TODO: We don't need the total in the UBO
    sdfSpritesBuffer[0] = numSdfSprites;
    gl.bindBuffer(glEnum.UNIFORM_BUFFER, sdfSpritesUBOBuffer);
    gl.bufferSubData(glEnum.UNIFORM_BUFFER, 0, sdfSpritesBuffer);

    gl.activeTexture(glEnum.TEXTURE0);
    gl.bindTexture(glEnum.TEXTURE_3D, sdfTexture3d.tex);
    gl.activeTexture(glEnum.TEXTURE1);
    gl.bindTexture(glEnum.TEXTURE_3D, sdfTextureMaterial3d.tex);

    gl.drawArraysInstanced(glEnum.TRIANGLE_STRIP, 0, 4, numSdfSprites);
    gl.disable(glEnum.DEPTH_TEST);

    // Ortho 2d Sprites
    //////////////////////
    resetFramebuffer(viewResolution[0], viewResolution[1]);

    const blitFramebuffer = (fb: Framebuffer) => {
        gl.useProgram(screenColorUvProgram.program);
        gl.activeTexture(glEnum.TEXTURE0);
        gl.bindTexture(glEnum.TEXTURE_2D, fb.colorTex);
        gl.bindBuffer(glEnum.ARRAY_BUFFER, unitQuadBuffer);
        gl.bindVertexArray(unitQuadVao);
        gl.drawArrays(glEnum.TRIANGLE_STRIP, 0, 4);
    }

    blitFramebuffer(gameFramebuffer);

    // Blit 
    gl.blendFunc(glEnum.SRC_ALPHA, glEnum.ONE_MINUS_SRC_ALPHA);
    gl.enable(glEnum.BLEND);

    gl.activeTexture(glEnum.TEXTURE0);
    gl.bindTexture(glEnum.TEXTURE_2D, whitePixelTexture);


    gl.useProgram(ortho2dProgram.program);
    gl.bindBuffer(glEnum.ARRAY_BUFFER, ortho2dBuffer);
    gl.bufferSubData(glEnum.ARRAY_BUFFER, 0, ortho2dSpritesFloatArray);
    gl.bindVertexArray(ortho2dVao);
    gl.drawArrays(glEnum.TRIANGLES, 0, ortho2dNumSprites * 6);

    gl.disable(glEnum.BLEND);

    numSdfSprites = 0;
    ortho2dNumSprites = 0;
};

export const initRenderer = async () => {
    const body = document.body;
    body.style.backgroundColor = "gray";

    glCanvas = createViewCanvas();
    body.appendChild(glCanvas);

    initWebgl(glCanvas);

    gameFramebuffer = createFramebuffer(viewResolution[0] * gameDownscale, viewResolution[1] * gameDownscale);
    resetFramebuffer(viewResolution[0], viewResolution[1]);

    whitePixelTexture = createTexture(1, 1, glEnum.RGBA, new Uint8Array([255, 255, 255, 255]));

    gl.disable(glEnum.CULL_FACE);

    sdfSpriteProgram = createProgram(sdfSpriteVert, sdfSpriteFrag);
    gl.useProgram(sdfSpriteProgram.program);
    getUniformLocation(sdfSpriteProgram, "_mv");
    getUniformLocation(sdfSpriteProgram, "_mp");
    getUniformLocation(sdfSpriteProgram, "_t");
    getUniformLocation(sdfSpriteProgram, "_m");
    getUniformLocation(sdfSpriteProgram, "_ld");
    getUniformLocation(sdfSpriteProgram, "_lc");
    getUniformLocation(sdfSpriteProgram, "_la");
    getUniformLocation(sdfSpriteProgram, "_lb");
    gl.uniform1i(sdfSpriteProgram.uniforms["_t"], 0);
    gl.uniform1i(sdfSpriteProgram.uniforms["_m"], 1);

    sdfFloorProgram = createProgram(sdfScreenVert, sdfFloorFrag);
    gl.useProgram(sdfFloorProgram.program);
    getUniformLocation(sdfFloorProgram, "_mv");
    getUniformLocation(sdfFloorProgram, "_mp");
    getUniformLocation(sdfFloorProgram, "_d");
    getUniformLocation(sdfFloorProgram, "_t");
    getUniformLocation(sdfFloorProgram, "_w");
    getUniformLocation(sdfFloorProgram, "_ld");
    getUniformLocation(sdfFloorProgram, "_lc");
    getUniformLocation(sdfFloorProgram, "_la");
    getUniformLocation(sdfFloorProgram, "_lb");
    gl.uniform1i(sdfFloorProgram.uniforms["_t"], 0);
    gl.uniform1i(sdfFloorProgram.uniforms["_w"], 1);

    ortho2dProgram = createProgram(ortho2dVert, uvColorFrag);
    gl.uniform1i(ortho2dProgram.uniforms["_s"], 0);
    screenColorUvProgram = createProgram(screenVert, uvColorFrag);
    gl.uniform1i(screenColorUvProgram.uniforms["_s"], 0);

    unitQuadBuffer = gl.createBuffer() as WebGLBuffer;

    gl.bindBuffer(glEnum.ARRAY_BUFFER, unitQuadBuffer);
    gl.bufferData(glEnum.ARRAY_BUFFER, new Float32Array([
        -1, 1,
        -1, -1,
        1, 1,
        1, -1,
    ]), glEnum.STATIC_DRAW);

    unitQuadVao = gl.createVertexArray() as WebGLVertexArrayObject;

    gl.bindVertexArray(unitQuadVao);
    gl.vertexAttribPointer(0, 2, glEnum.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);

    // Ortho 2d
    ortho2dBuffer = gl.createBuffer() as WebGLBuffer;
    gl.bindBuffer(glEnum.ARRAY_BUFFER, ortho2dBuffer);
    gl.bufferData(glEnum.ARRAY_BUFFER, ortho2dArraySizeFloats * 4, glEnum.DYNAMIC_DRAW);
    ortho2dVao = gl.createVertexArray() as WebGLVertexArrayObject;
    gl.bindVertexArray(ortho2dVao);
    gl.vertexAttribPointer(0, 2, glEnum.FLOAT, false, ortho2dVertexAttributesSizeFloats * 4, 0);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(1, 3, glEnum.FLOAT, false, ortho2dVertexAttributesSizeFloats * 4, 2 * 4);
    gl.enableVertexAttribArray(1);
    gl.vertexAttribPointer(2, 3, glEnum.FLOAT, false, ortho2dVertexAttributesSizeFloats * 4, 5 * 4);
    gl.enableVertexAttribArray(2);
    gl.vertexAttribPointer(3, 4, glEnum.FLOAT, false, ortho2dVertexAttributesSizeFloats * 4, 8 * 4);
    gl.enableVertexAttribArray(3);

    // SDF sprite 3d textures
    sdfTexture3d = createTexture3d(sdfTextureDepth * sdfSpritesAtlasSide, sdfTextureDepth * sdfSpritesAtlasSide, sdfTextureDepth, glEnum.LINEAR);
    sdfTextureMaterial3d = createTexture3d(sdfTextureDepth * sdfSpritesAtlasSide, sdfTextureDepth * sdfSpritesAtlasSide, sdfTextureDepth, glEnum.NEAREST);

    // UBO
    const sdfUBOIndex = gl.getUniformBlockIndex(sdfSpriteProgram.program, "_b");
    gl.uniformBlockBinding(sdfSpriteProgram.program, sdfUBOIndex, 0);

    sdfSpritesUBOBuffer = createUBO(4 * (maxSdfSprites * 12 + 4));
    gl.bindBufferBase(glEnum.UNIFORM_BUFFER, 0, sdfSpritesUBOBuffer);
    gl.bindBufferRange(glEnum.UNIFORM_BUFFER, 0, sdfSpritesUBOBuffer, 0, 4 * (maxSdfSprites * 12 + 4));

    projMatrix = mat4(1);
    /*     const orthoZoom = 9.0;
        mat4Ortho(orthoZoom, orthoZoom, 0.01, 100, projMatrix); */
    mat4Perspective(45 * Deg, viewResolution[0] / viewResolution[1], 0.01, 1000, projMatrix);
    viewMatrix = mat4(1);

    if (DEBUG) {
        debugDiv = document.createElement("div");

        const style = debugDiv.style;
        style.top = "0";
        style.left = "0";
        style.position = "absolute";
        style.backgroundColor = "black";
        style.color = "white";

        debugDiv.innerHTML = "Debug data here";

        document.body.appendChild(debugDiv);
    }
};

export const bakeTextures = () => {

    terrainNoiseTexture = createTexture3d(terrainTextureSize, terrainTextureSize, 1, glEnum.LINEAR, true, glEnum.RGBA16F);
    const data = fbmTexture(terrainTextureSize, 8, 2, 0.3);
    texture3dSubdata(terrainNoiseTexture, 0, 0, data, terrainTextureSize, terrainTextureSize, glEnum.RGBA);


    whiteNoiseTexture = createTexture3d(whiteNoiseTextureSize, whiteNoiseTextureSize, 1, glEnum.LINEAR, true, glEnum.RG16F);
    const whiteNoise = new Float32Array(2 * whiteNoiseTextureSize * whiteNoiseTextureSize);
    fillBufferWithRandomRange(whiteNoise, 0, 1);
    texture3dSubdata(whiteNoiseTexture, 0, 0, whiteNoise, whiteNoiseTextureSize, whiteNoiseTextureSize, glEnum.RG);

    //  debugViewTextureInACanvas(whiteNoise, whiteNoiseTextureSize, whiteNoiseTextureSize, 1);
};

export const debugViewTextureInACanvas = (data: Float32Array, w: number, h: number, c: number) => {
    const pixels = new Uint8ClampedArray(w * h * 4);
    for (let i = 0; i < w * h; ++i) {
        const rIdx = i * c;
        const pIdx = i * 4;
        pixels[pIdx] = saturate(data[rIdx]) * 255;
        pixels[pIdx + 1] = (c > 1 ? saturate(data[rIdx + 1]) : 0) * 255;
        pixels[pIdx + 2] = (c > 2 ? saturate(data[rIdx + 2]) : 0) * 255;
        pixels[pIdx + 3] = 1 * 255;
    }

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;
    const imgData = new ImageData(pixels, w, h);
    ctx.putImageData(imgData, 0, 0);
    const img = document.createElement("img");
    img.src = canvas.toDataURL();
    document.body.appendChild(img);
};

/* 
// Needs inverse projection
export const getViewPointAtScreenPos = (screenPos: Vec3, viewPos: Vec4) => {
    // todo: borrow
    const v = vec4(screenPos[0] / viewResolution[0], screenPos[1] / viewResolution[1], screenPos[2], 1);
    vecFMKA(v, 2, vec4Splay(-1), v);
    mat4Vec4Mul(invProjMatrix, v, viewPos);
    vecMulK(viewPos, 1 / viewPos[3], viewPos);
};

 */